/**
 * üé® Figma Design Token Sync Script
 * Fetches design tokens from Figma Variables and updates tokens.css
 */

const fs = require('fs');
const path = require('path');
const https = require('https');

// Configuration from environment variables
const FIGMA_ACCESS_TOKEN = process.env.FIGMA_ACCESS_TOKEN;
const FIGMA_FILE_ID = process.env.FIGMA_FILE_ID || 'iWOdfts5H17fHjAzfXiK5D'; // Fallback to your File ID
const FORCE_UPDATE = process.env.FORCE_UPDATE === 'true';

if (!FIGMA_ACCESS_TOKEN || !FIGMA_FILE_ID) {
  console.error('‚ùå Error: FIGMA_ACCESS_TOKEN and FIGMA_FILE_ID environment variables are required');
  process.exit(1);
}

/**
 * Makes HTTPS request to Figma API
 */
function figmaRequest(endpoint) {
  return new Promise((resolve, reject) => {
    const options = {
      hostname: 'api.figma.com',
      path: endpoint,
      method: 'GET',
      headers: {
        'X-Figma-Token': FIGMA_ACCESS_TOKEN,
        'Content-Type': 'application/json'
      }
    };

    const req = https.request(options, (res) => {
      let data = '';
      
      res.on('data', (chunk) => {
        data += chunk;
      });
      
      res.on('end', () => {
        try {
          const parsed = JSON.parse(data);
          if (res.statusCode !== 200) {
            reject(new Error(`Figma API error: ${parsed.message || 'Unknown error'}`));
          } else {
            resolve(parsed);
          }
        } catch (error) {
          reject(new Error(`Failed to parse Figma API response: ${error.message}`));
        }
      });
    });

    req.on('error', reject);
    req.end();
  });
}

/**
 * Converts Figma token name to CSS custom property name
 */
function tokenNameToCSSVar(name) {
  return `--${name.toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/[^a-z0-9-]/g, '')
    .replace(/--+/g, '-')
    .replace(/^-|-$/g, '')}`;
}

/**
 * Converts Figma color value to CSS color
 */
function figmaColorToCSS(color) {
  if (!color || typeof color !== 'object') return '#000000';
  
  const { r = 0, g = 0, b = 0, a = 1 } = color;
  
  if (a === 1) {
    // Use hex for opaque colors
    const toHex = (val) => Math.round(val * 255).toString(16).padStart(2, '0');
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  } else {
    // Use rgba for transparent colors
    return `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, ${a})`;
  }
}

/**
 * Main sync function
 */
async function syncTokens() {
  try {
    console.log('üîç Fetching design tokens from Figma...');
    
    // Fetch local variables (design tokens) from Figma file
    const variablesResponse = await figmaRequest(`/v1/files/${FIGMA_FILE_ID}/variables/local`);
    
    console.log(`üìä Found ${Object.keys(variablesResponse.meta.variables || {}).length} variables`);

    const tokens = {};
    const variables = variablesResponse.meta.variables || {};
    const variableCollections = variablesResponse.meta.variableCollections || {};

    // Process each variable
    for (const [id, variable] of Object.entries(variables)) {
      const { name, valuesByMode } = variable;
      
      // Get default mode value (usually the first mode)
      const modes = Object.keys(valuesByMode);
      if (modes.length === 0) continue;
      
      const defaultMode = modes[0];
      const value = valuesByMode[defaultMode];
      
      let cssValue;
      
      if (typeof value === 'object' && value.type === 'VARIABLE_ALIAS') {
        // Handle variable references
        const referencedVar = variables[value.id];
        if (referencedVar) {
          cssValue = `var(${tokenNameToCSSVar(referencedVar.name)})`;
        }
      } else if (variable.resolvedType === 'COLOR') {
        // Handle color values
        cssValue = figmaColorToCSS(value);
      } else if (typeof value === 'number') {
        // Handle numeric values (spacing, sizing, etc.)
        cssValue = `${value}px`;
      } else {
        // Handle other values as strings
        cssValue = String(value);
      }
      
      if (cssValue) {
        tokens[tokenNameToCSSVar(name)] = cssValue;
      }
    }

    console.log(`‚úÖ Processed ${Object.keys(tokens).length} design tokens`);

    // Generate CSS content
    const cssContent = `/**
 * üé® Design Tokens - Auto-generated from Figma
 * Last sync: ${new Date().toISOString()}
 * File ID: ${FIGMA_FILE_ID}
 * 
 * ‚ö†Ô∏è DO NOT EDIT THIS FILE MANUALLY
 * Changes will be overwritten on next sync
 */

:root {
${Object.entries(tokens)
  .sort(([a], [b]) => a.localeCompare(b))
  .map(([name, value]) => `  ${name}: ${value};`)
  .join('\n')}
}

/* ===========================================
 * SEMANTIC TOKEN MAPPINGS
 * Map base tokens to semantic usage
 * =========================================== */

:root {
  /* Brand Colors */
  --color-brand-primary: var(--color-blue-900, #1e293b);
  --color-brand-accent: var(--color-green-600, #059669);
  
  /* Background Colors */
  --color-bg-page: var(--color-slate-50, #f8fafc);
  --color-bg-surface: var(--color-white, #ffffff);
  --color-bg-subtle: var(--color-slate-100, #f1f5f9);
  
  /* Text Colors */
  --color-text-primary: var(--color-slate-900, #0f172a);
  --color-text-secondary: var(--color-slate-600, #475569);
  --color-text-on-primary: var(--color-white, #ffffff);
  --color-text-on-accent: var(--color-white, #ffffff);
  
  /* Border Colors */
  --color-border-default: var(--color-slate-200, #e2e8f0);
  
  /* Interactive Colors */
  --color-interactive-focus: var(--color-blue-500, #3b82f6);
  
  /* State Colors */
  --color-state-success: var(--color-green-600, #059669);
  --color-state-warning: var(--color-yellow-500, #eab308);
  --color-state-error: var(--color-red-600, #dc2626);
  
  /* Typography Scale */
  --text-display-size: var(--font-size-4xl, 2.25rem);
  --text-h1-size: var(--font-size-3xl, 1.875rem);
  --text-h2-size: var(--font-size-2xl, 1.5rem);
  --text-h3-size: var(--font-size-xl, 1.25rem);
  --text-body-size: var(--font-size-base, 1rem);
  --text-small-size: var(--font-size-sm, 0.875rem);
  --text-caption-size: var(--font-size-xs, 0.75rem);
  
  /* Line Heights */
  --text-display-line-height: 1.2;
  --text-h1-line-height: 1.3;
  --text-h2-line-height: 1.4;
  --text-h3-line-height: 1.4;
  --text-body-line-height: 1.5;
  --text-small-line-height: 1.4;
  --text-caption-line-height: 1.3;
  
  /* Font Weights */
  --font-weight-normal: 400;
  --font-weight-medium: 500;
  --font-weight-semibold: 600;
  --font-weight-bold: 700;
  
  /* Spacing Scale (8-point grid) */
  --space-1: var(--spacing-xs, 4px);
  --space-2: var(--spacing-sm, 8px);
  --space-3: var(--spacing-md, 12px);
  --space-4: var(--spacing-lg, 16px);
  --space-5: var(--spacing-xl, 20px);
  --space-6: var(--spacing-2xl, 24px);
  --space-8: var(--spacing-3xl, 32px);
  --space-10: var(--spacing-4xl, 40px);
  --space-12: var(--spacing-5xl, 48px);
  
  /* Border Radius */
  --radius-component-sm: var(--border-radius-sm, 2px);
  --radius-component-md: var(--border-radius-md, 3px);
  --radius-component-lg: var(--border-radius-lg, 4px);
}
`;

    // Write tokens to file
    const tokensPath = path.join(__dirname, 'tokens.css');
    const currentContent = fs.existsSync(tokensPath) ? fs.readFileSync(tokensPath, 'utf8') : '';
    
    if (currentContent !== cssContent || FORCE_UPDATE) {
      fs.writeFileSync(tokensPath, cssContent, 'utf8');
      console.log('‚úÖ Design tokens updated successfully!');
      console.log(`üìÑ Written to: ${tokensPath}`);
    } else {
      console.log('‚ÑπÔ∏è No changes detected in design tokens');
    }

  } catch (error) {
    console.error('‚ùå Error syncing tokens:', error.message);
    process.exit(1);
  }
}

// Run the sync
syncTokens();